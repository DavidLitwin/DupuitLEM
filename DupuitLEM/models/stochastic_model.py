"""
Landscape evolution model using the GroundwaterDupuitPercolator in which
recharge occurs with events selected from a probability distribution. The shear
stress that results from overland flow is tracked and averaged to update topography.

Author: David Litwin

"""
import time
import numpy as np

from landlab.components import (
    GroundwaterDupuitPercolator,
    FlowAccumulator,
    LinearDiffuser,
    LakeMapperBarnes,
    DepressionFinderAndRouter,
    )
from DupuitLEM.grid_functions.grid_funcs import calc_avg_hydraulic_conductivity, calc_shear_stress_at_node


class StochasticRechargeShearStress:

    """
    Simple groundwater landscape evolution model with constant uplift/baselevel
    fall, linear hillslope diffusive transport, and detachment limited erosion
    generated by accumulated groundwater return flow and saturation excess overland flow.
    Recharge volumes are selected from a probability distribution.
    The shear stress that results from overland flow is tracked and averaged to update topography.
    """

    def __init__(self,params,save_output=True):

        self._grid = params.pop("grid")
        self._cores = self._grid.core_nodes

        self.Ks = params.pop("hydraulic_conductivity") #[m/s]
        self.K0 = params.pop("min_hydraulic_conductivity")  #[m/s]
        self.d_k = params.pop("characteristic_k_depth")
        self.n = params.pop("porosity")
        self.r = params.pop("regularization_factor")
        self.c = params.pop("courant_coefficient")
        self.vn = params.pop("vn_coefficient")

        self.w0 = params.pop("permeability_production_rate") #[m/s]
        self.d_s = params.pop("characteristic_w_depth")
        self.U = params.pop("uplift_rate") # uniform uplift [m/s]
        self.m = params.pop("m_sp") #Exponent on Q []
        self.n = params.pop("n_sp") #Exponent on S []
        self.K = params.pop("k_sp") #erosivity coefficient [m-1/2 sâˆ’1/2]
        self.D = params.pop("hillslope_diffusivity") # hillslope diffusivity [m2/s]

        self.T_m = params.pop("total_time") # total geomorphic simulation time [s]
        self.T_h = params.pop("hydrological_time") # time of a hydrological simulation before morphologic update [s]
        self.MSF = params.pop("morphologic_scaling_factor") # morphologic scaling factor [-]

        self.p_seed = param.pop("precpitation_seed")
        self.storm_dt = params.pop("mean_storm_duration")
        self.interstorm_dt = params.pop("mean_interstorm_duration")
        self.p = params.pop("mean_storm_depth")

        self._elev = self._grid.at_node["topographic__elevation"]
        self._base = self._grid.at_node["aquifer_base__elevation"]
        self._wt = self._grid.at_node["water_table__elevation"]
        self._gw_flux = self._grid.add_zeros('node', 'groundwater__specific_discharge_node')

        if save_output:
            self._output_interval = params.pop("output_interval")
            self._output_fields = params.pop("output_fields")
            self._track_times = params.pop("track_times")


        # initialize model components
        self.gdp = GroundwaterDupuitPercolator(self._grid, porosity=self.n, \
                                          regularization_f=self.r, \
                                          courant_coefficient=self.c, vn_coefficient = self.vn)
        self.fa = FlowAccumulator(self._grid, surface='topographic__elevation', flow_director='D8',  \
                              runoff_rate='average_surface_water__specific_discharge')
        self.lmb = LakeMapperBarnes(self._grid, method='D8', fill_flat=False,
                                      surface='topographic__elevation',
                                      fill_surface='topographic__elevation',
                                      redirect_flow_steepest_descent=False,
                                      reaccumulate_flow=False,
                                      track_lakes=False,
                                      ignore_overfill=True)
        self.ld = LinearDiffuser(self._grid, linear_diffusivity = self.D)
        self.dfr = DepressionFinderAndRouter(self._grid)
        self.pd = PrecipitationDistribution(self._grid, mean_storm_duration=self.storm_dt,
            mean_interstorm_duration=self.interstorm_dt, mean_storm_depth=self.p,
            total_t=self.T_h)


    def generate_exp_precip(self):

        storm_dts = []
        interstorm_dts = []
        intensities = []
        precip.seed_generator(seedval=self.p_seed)
        for (storm_dt, interstorm_dt) in precip.yield_storms():
            storm_dts.append(storm_dt)
            interstorm_dts.append(interstorm_dt)
            intensities.append(float(grid.at_grid['rainfall__flux']))

        return storm_dts, interstorm_dts, intensities

    def run_exponential_recharge_model(self)
