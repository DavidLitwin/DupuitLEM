"""
Hydrological models for DupuitLEM:
    HydrologySteadyStreamPower:
    - steady recharge
    HydrologyEventStreamPower:
    - stochastic recharge generated from landlab component PrecipitationDistribution
    HydrologyEventThresholdStreamPower
    - stochastic recharge generated from landlab component PrecipitationDistribution
    - approach allows for correct averaging of discharge when there is an incision threshold
    HydrologyEventVadoseStreamPower
    - stochastic precip generated by landlab component PrecipitationDistribution
    - precip and ET handled in vadose profile by SchenkVadoseModel
    - recharge is infiltration into vadose profile below water table, can occur during storms
    - extraction is ET from vadose profile below water table, can occur during interstorms
    HydrologyEventVadoseThresholdStreamPower
    - stochastic precip generated by landlab component PrecipitationDistribution
    - precip and ET handled in vadose profile by SchenkVadoseModel
    - recharge is infiltration into vadose profile below water table, can occur during storms
    - extraction is ET from vadose profile below water table, can occur during interstorms
    - approach allows for correct averaging of discharge when there is an incision threshold

    --------
    Notes:
    Designed for use with StreamPowerModel class. Calculate hydrological state
    and update fields that are used by FastscapeEroder in the StreamPowerModel
    to calculate erosion rates.


Author: David Litwin

Date: 19 May 2020
"""

import numpy as np

from landlab.components import (
    FlowDirectorD8,
    FlowDirectorSteepest,
    FlowAccumulator,
    LakeMapperBarnes,
    DepressionFinderAndRouter,
)


class HydrologicalModel:
    """
    Base class for hydrological model.

    Parameters
    -----
    grid: a landlab grid with GroundwaterDupuitPercolator already instantiated
    routing_method: Either 'D8' or 'Steepest'. This is the routing method for the
        FlowDirector component. 'Steepest' allows the use of non-raster grids.

    """

    def __init__(self, grid, routing_method):

        self._grid = grid

        if routing_method == "D8":
            self.fd = FlowDirectorD8(self._grid)
        elif routing_method == "Steepest":
            self.fd = FlowDirectorSteepest(self._grid)
        else:
            raise ValueError("routing_method must be either D8 or Steepest.")

        self.fa = FlowAccumulator(
            self._grid,
            surface="topographic__elevation",
            flow_director=self.fd,
            runoff_rate="average_surface_water__specific_discharge",
        )
        self.lmb = LakeMapperBarnes(
            self._grid,
            method=routing_method,
            fill_flat=False,
            surface="topographic__elevation",
            fill_surface="topographic__elevation",
            redirect_flow_steepest_descent=False,
            reaccumulate_flow=False,
            track_lakes=False,
            ignore_overfill=True,
        )
        self.dfr = DepressionFinderAndRouter(self._grid)

    def run_step(self):
        raise NotImplementedError


class HydrologySteadyStreamPower(HydrologicalModel):
    """"
    Run hydrological model for steady recharge provided to the
    GroundwaterDupuitPercolator. HydrologySteadyStreamPower is meant to be
    passed to the StreamPowerModel, where erosion rate is calculated.
    An additional field, surface_water_area_norm__discharge is calculated
    by dividing the effective discharge by the square root of the drainage area.
    This accounts for how channel width varies with the square root of area.
    When combined with FastscapeEroder with m=1 and n=1, this produces erosion
    with the form E = K v0 Q* sqrt(a) S, where Q*=Q/(pA).

    Parameters
    -----
    grid: landlab grid
    precip_generator: instantiated PrecipitationDistribution
    groundwater_model: instantiated GroundwaterDupuitPercolator
    """

    def __init__(
        self,
        grid,
        routing_method="D8",
        groundwater_model=None,
        hydrological_timestep=1e5,
    ):
        super().__init__(grid, routing_method)

        self.gdp = groundwater_model
        self.T_h = hydrological_timestep

        self.q_an = self._grid.add_zeros("node", "surface_water_area_norm__discharge")
        self.area = self._grid.at_node["drainage_area"]
        self.q = self._grid.at_node["surface_water__discharge"]

    def run_step(self):
        """
        Run steady model one step. Update groundwater state, route and
        accumulate flow, updating surface_water__discharge.
        """

        # run gw model
        self.gdp.run_with_adaptive_time_step_solver(self.T_h)
        self.number_substeps = self.gdp.number_of_substeps

        # find pits for flow accumulation
        self.dfr._find_pits()
        if self.dfr._number_of_pits > 0:
            self.lmb.run_one_step()

        # run flow accumulation on average_surface_water__specific_discharge
        self.fa.run_one_step()

        # add a criteria that effectively cuts Q* off at 1 (greater due to numerical issues)
        qmax = self.gdp.recharge * self.area
        self.q[self.q > qmax] = qmax[self.q > qmax]

        # discharge field with form for Q*
        self.q_an[:] = np.divide(
            self.q, np.sqrt(self.area), where=self.area > 0, out=np.zeros_like(self.q)
        )


class HydrologyEventStreamPower(HydrologicalModel):

    """"
    Run hydrological model for series of event-interevent pairs, calculate
    instantaneous flow rate at the beginning and end of event. Runoff accounts
    for discharge during both events and interevents.
    HydrologyEventStreamPower is meant to be passed to the StreamPowerModel,
    where erosion rate is calculated.
    An additional field, surface_water_area_norm__discharge is calculated
    by dividing the effective discharge by the square root of the drainage area.
    This accounts for how channel width varies with the square root of area.
    When combined with FastscapeEroder with m=1 and n=1, this produces erosion
    with the form E = K v0 Q* sqrt(a) S, where Q*=Q/(pA).

    Parameters
    -----
    grid: landlab grid
    precip_generator: instantiated PrecipitationDistribution
    groundwater_model: instantiated GroundwaterDupuitPercolator

    """

    def __init__(
        self, grid, routing_method="D8", precip_generator=None, groundwater_model=None,
    ):

        super().__init__(grid, routing_method)

        self.q_eff = self._grid.add_zeros("node", "surface_water_effective__discharge")
        self.q_an = self._grid.add_zeros("node", "surface_water_area_norm__discharge")
        self.area = self._grid.at_node["drainage_area"]
        self.pd = precip_generator
        self.gdp = groundwater_model
        self.T_h = self.pd._run_time

    def generate_exp_precip(self):
        """
        Generate all storms ahead of time. Used with run_step_record_state.
        """

        storm_dts = []
        interstorm_dts = []
        intensities = []

        for (storm_dt, interstorm_dt) in self.pd.yield_storms():
            storm_dts.append(storm_dt)
            interstorm_dts.append(interstorm_dt)
            intensities.append(float(self._grid.at_grid["rainfall__flux"]))

        self.storm_dts = storm_dts
        self.interstorm_dts = interstorm_dts
        self.intensities = intensities

    def run_step(self):
        """"
        Run hydrological model for series of event-interevent pairs, calculate
        flow rates at end of events and interevents over total_hydrological_time.
        Update groundwater state, routes and accumulates flow, update
        surface_water_effective__discharge and surface_water_area_norm__discharge.
        """

        # find and route flow if there are pits
        self.dfr._find_pits()
        if self.dfr._number_of_pits > 0:
            self.lmb.run_one_step()

        # update flow directions
        self.fd.run_one_step()

        self.max_substeps_storm = 0
        self.max_substeps_interstorm = 0
        q_total_vol = np.zeros_like(self.q_eff)
        # q2 = np.zeros_like(self.q_eff)
        for (storm_dt, interstorm_dt) in self.pd.yield_storms():

            intensity = float(self._grid.at_grid["rainfall__flux"])

            # q0 = q2.copy()  # save prev end of interstorm flow rate

            # run event, accumulate flow
            self.gdp.recharge = intensity
            self.gdp.run_with_adaptive_time_step_solver(storm_dt)
            _, q = self.fa.accumulate_flow(update_flow_director=False)
            q1 = q.copy()
            self.max_substeps_storm = max(
                self.max_substeps_storm, self.gdp.number_of_substeps
            )

            # run interevent, accumulate flow
            self.gdp.recharge = 0.0
            self.gdp.run_with_adaptive_time_step_solver(max(interstorm_dt, 1e-15))
            _, q = self.fa.accumulate_flow(update_flow_director=False)
            q2 = q.copy()
            self.max_substeps_interstorm = max(
                self.max_substeps_interstorm, self.gdp.number_of_substeps
            )

            # volume of runoff contributed during timestep
            q_total_vol += q1 * storm_dt + q2 * interstorm_dt

        self.q_eff[:] = q_total_vol / self.T_h
        self.q_an[:] = np.divide(
            self.q_eff,
            np.sqrt(self.area),
            where=self.area > 0,
            out=np.zeros_like(self.q_eff),
        )

    def run_step_record_state(self):
        """"
        Run hydrological model for series of event-interevent pairs, calculate
        flow rates at end of events and interevents over total_hydrological_time.
        Effective flow rates are calculated during event periods only.
        Update groundwater state, routes and accumulates flow, update
        surface_water_effective__discharge and surface_water_area_norm__discharge.

        track the state of the model:
            time: (s)
            intensity: rainfall intensity (m/s)
            wtrel_all: relative water table position (-)
            qs_all: surface water specific discharge (m/s)
            Q_all: discharge (m3/s)

        """

        # generate new precip time series
        self.generate_exp_precip()

        # find and route flow if there are pits
        self.dfr._find_pits()
        if self.dfr._number_of_pits > 0:
            self.lmb.run_one_step()

        # update flow directions
        self.fd.run_one_step()

        # fields to record:
        Ns = 2 * len(self.storm_dts) + 1
        N = len(self.q_eff)
        self.time = np.zeros(Ns)
        self.intensity = np.zeros(Ns)
        # all discharge
        self.Q_all = np.zeros((Ns, N))
        # water table elevation
        self.wt_all = np.zeros((Ns, N))
        self.wt_all[0, :] = self._grid.at_node["water_table__elevation"].copy()
        # all surface water specific discharge
        self.qs_all = np.zeros((Ns, N))

        self.max_substeps_storm = 0
        self.max_substeps_interstorm = 0

        q_total_vol = np.zeros_like(self.q_eff)
        # q2 = np.zeros_like(self.q_eff)
        for i in range(len(self.storm_dts)):
            # q0 = q2.copy()  # save prev end of interstorm flow rate

            # run event, accumulate flow
            self.gdp.recharge = self.intensities[i]
            self.gdp.run_with_adaptive_time_step_solver(self.storm_dts[i])
            _, q = self.fa.accumulate_flow(update_flow_director=False)
            q1 = q.copy()
            self.max_substeps_storm = max(
                self.max_substeps_storm, self.gdp.number_of_substeps
            )

            # record event
            self.time[i * 2 + 1] = self.time[i * 2] + self.storm_dts[i]
            self.intensity[i * 2] = self.intensities[i]
            self.Q_all[i * 2 + 1, :] = self._grid.at_node["surface_water__discharge"]
            self.wt_all[i * 2 + 1, :] = self._grid.at_node["water_table__elevation"]
            self.qs_all[i * 2 + 1, :] = self._grid.at_node[
                "average_surface_water__specific_discharge"
            ]

            # run interevent, accumulate flow
            self.gdp.recharge = 0.0
            self.gdp.run_with_adaptive_time_step_solver(
                max(self.interstorm_dts[i], 1e-15)
            )
            _, q = self.fa.accumulate_flow(update_flow_director=False)
            q2 = q.copy()
            self.max_substeps_interstorm = max(
                self.max_substeps_interstorm, self.gdp.number_of_substeps
            )

            # record interevent
            self.time[i * 2 + 2] = self.time[i * 2 + 1] + self.interstorm_dts[i]
            self.Q_all[i * 2 + 2, :] = self._grid.at_node["surface_water__discharge"]
            self.wt_all[i * 2 + 2, :] = self._grid.at_node["water_table__elevation"]
            self.qs_all[i * 2 + 2, :] = self._grid.at_node[
                "average_surface_water__specific_discharge"
            ]

            # volume of runoff contributed during timestep
            q_total_vol += q1 * self.storm_dts[i] + q2 * self.interstorm_dts[i]

        self.q_eff[:] = q_total_vol / self.T_h
        self.q_an[:] = np.divide(
            self.q_eff,
            np.sqrt(self.area),
            where=self.area > 0,
            out=np.zeros_like(self.q_eff),
        )


class HydrologyEventThresholdStreamPower(HydrologyEventStreamPower):
    """
    This model expands the HydrologyEventStreamPower model for
    cases where there is a streampower incision threshold.
    HydrologyEventThresholdStreamPower is meant to be passed to the
    StreamPowerModel, where erosion rate is calculated. Rather than tracking
    discharge at storms and interstorms, erosion-producing discharge Q-Q0 is
    tracked, and returned in a fashion that is correctly averaged with threshold
    accounted for in the field "surface_water_effective__discharge".
    CONSEQUENTLY ONE SHOULD LEAVE THE INCISION THRESHOLD FIELD OF
    FastscapeEroder SET TO ZERO! For the same reason, this field has a different
    meaning when using the threshold model: it is not an actual discharge,
    but an effective value that also accounts for geomorphic properties related
    to the threshold streampower.

    Parameters
    -----
    grid: landlab grid
    routing_method: either "D8" or "Steepest"
    precip_generator: instantiated PrecipitationDistribution
    groundwater_model: instantiated GroundwaterDupuitPercolator
    E0: the streampower incision threshold in the equation
        E = K v0 Q* sqrt(a) S - E0, where Q*=Q/(pA). Units: L/T
        Default value: 0.0
    sp_coefficient: streampower coefficient used in the FastscapeEroder
        component. Note that in DupuitLEM, the expected value has units 1/L,
        because it takes a coefficient K/p, where K is the usual streampower
        coefficient, with units 1/T, and p is the mean precipitation rate with
        units L/T.
        Default value: 1e-12
    """

    def __init__(
        self,
        grid,
        routing_method="D8",
        precip_generator=None,
        groundwater_model=None,
        sp_threshold=0.0,
        sp_coefficient=1e-5,
    ):
        super().__init__(grid, routing_method, precip_generator, groundwater_model)
        self.E0 = sp_threshold
        self.Ksp = sp_coefficient
        self.Q0 = self._grid.add_zeros("node", "critical_erosion__discharge")
        self._elev = self._grid.at_node["topographic__elevation"]
        self._recievers = self._grid.at_node["flow__link_to_receiver_node"]

        if routing_method == "D8":
            self._calc_grad = self._grid.calc_grad_at_d8
        else:
            self._calc_grad = self._grid.calc_grad_at_link

    def run_step(self):
        """"
        Run hydrological model for series of event-interevent pairs, calculate
        flow rates at end of events and interevents over total_hydrological_time.
        Update groundwater state, routes and accumulates flow, update
        surface_water_effective__discharge and surface_water_area_norm__discharge,
        where surface_water_effective__discharge is discharge minus the discharge
        equivalent of the streampower incision threshold.
        """

        # find and route flow if there are pits
        self.dfr._find_pits()
        if self.dfr._number_of_pits > 0:
            self.lmb.run_one_step()

        # update flow directions
        self.fd.run_one_step()

        # calculate critical_erosion__discharge
        dzdx = self._calc_grad(self._elev)
        S = abs(dzdx[self._recievers])  # slope is in direction of flow
        _, _ = self.fa.accumulate_flow(update_flow_director=False)  # to update area
        self.Q0[:] = np.divide(
            self.E0 * np.sqrt(self.area),
            self.Ksp * S,
            where=S > 0.0,
            out=np.zeros_like(S),
        )

        self.max_substeps_storm = 0
        self.max_substeps_interstorm = 0
        q_total_vol = np.zeros_like(self.q_eff)
        # q2 = np.zeros_like(self.q_eff)
        for (storm_dt, interstorm_dt) in self.pd.yield_storms():

            intensity = float(self._grid.at_grid["rainfall__flux"])

            # q0 = q2.copy()  # save prev end of interstorm flow rate

            # run event, accumulate flow
            self.gdp.recharge = intensity
            self.gdp.run_with_adaptive_time_step_solver(storm_dt)
            _, q = self.fa.accumulate_flow(update_flow_director=False)
            q1 = np.maximum(q - self.Q0, 0.0)
            # print('storm q:%f, q1:%f'%(q[4], q1[4]))
            self.max_substeps_storm = max(
                self.max_substeps_storm, self.gdp.number_of_substeps
            )

            # run interevent, accumulate flow
            self.gdp.recharge = 0.0
            self.gdp.run_with_adaptive_time_step_solver(max(interstorm_dt, 1e-15))
            _, q = self.fa.accumulate_flow(update_flow_director=False)
            q2 = np.maximum(q - self.Q0, 0.0)
            # print('interstorm q:%f, q2:%f'%(q[4], q2[4]))
            self.max_substeps_interstorm = max(
                self.max_substeps_interstorm, self.gdp.number_of_substeps
            )

            # volume of runoff contributed during timestep
            q_total_vol += q1 * storm_dt + q2 * interstorm_dt
            # print('storm dt:%f'%storm_dt)

        self.q_eff[:] = q_total_vol / self.T_h
        self.q_an[:] = np.divide(
            self.q_eff,
            np.sqrt(self.area),
            where=self.area > 0,
            out=np.zeros_like(self.q_eff),
        )

    def run_step_record_state(self):
        """"
        Run hydrological model for series of event-interevent pairs, calculate
        flow rates at end of events and interevents over total_hydrological_time.
        Effective flow rates are calculated during event periods only.
        Update groundwater state, routes and accumulates flow, update
        surface_water_effective__discharge and surface_water_area_norm__discharge.

        track the state of the model:
            time: (s)
            intensity: rainfall intensity (m/s)
            wtrel_all: relative water table position (-)
            qs_all: surface water specific discharge (m/s)
            Q_all: discharge (m3/s)

        """

        # generate new precip time series
        self.generate_exp_precip()

        # find and route flow if there are pits
        self.dfr._find_pits()
        if self.dfr._number_of_pits > 0:
            self.lmb.run_one_step()

        # update flow directions
        self.fd.run_one_step()

        # calculate critical_erosion__discharge
        dzdx = self._calc_grad(self._elev)
        S = abs(dzdx[self._recievers])  # slope is in direction of flow
        _, _ = self.fa.accumulate_flow(update_flow_director=False)  # to update area
        self.Q0[:] = np.divide(
            self.E0 * np.sqrt(self.area),
            self.Ksp * S,
            where=S > 0.0,
            out=np.zeros_like(S),
        )

        # fields to record:
        Ns = 2 * len(self.storm_dts) + 1
        N = len(self.q_eff)
        self.time = np.zeros(Ns)
        self.intensity = np.zeros(Ns)
        # all discharge
        self.Q_all = np.zeros((Ns, N))
        # water table elevation
        self.wt_all = np.zeros((Ns, N))
        self.wt_all[0, :] = self._grid.at_node["water_table__elevation"].copy()
        # all surface water specific discharge
        self.qs_all = np.zeros((Ns, N))

        self.max_substeps_storm = 0
        self.max_substeps_interstorm = 0

        q_total_vol = np.zeros_like(self.q_eff)
        # q2 = np.zeros_like(self.q_eff)
        for i in range(len(self.storm_dts)):
            # q0 = q2.copy()  # save prev end of interstorm flow rate

            # run event, accumulate flow
            self.gdp.recharge = self.intensities[i]
            self.gdp.run_with_adaptive_time_step_solver(self.storm_dts[i])
            _, q = self.fa.accumulate_flow(update_flow_director=False)
            q1 = np.maximum(q - self.Q0, 0.0)
            # print('storm q:%f, q1:%f'%(q[4], q1[4]))
            self.max_substeps_storm = max(
                self.max_substeps_storm, self.gdp.number_of_substeps
            )

            # record event
            self.time[i * 2 + 1] = self.time[i * 2] + self.storm_dts[i]
            self.intensity[i * 2] = self.intensities[i]
            self.Q_all[i * 2 + 1, :] = self._grid.at_node["surface_water__discharge"]
            self.wt_all[i * 2 + 1, :] = self._grid.at_node["water_table__elevation"]
            self.qs_all[i * 2 + 1, :] = self._grid.at_node[
                "average_surface_water__specific_discharge"
            ]

            # run interevent, accumulate flow
            self.gdp.recharge = 0.0
            self.gdp.run_with_adaptive_time_step_solver(
                max(self.interstorm_dts[i], 1e-15)
            )
            _, q = self.fa.accumulate_flow(update_flow_director=False)
            q2 = np.maximum(q - self.Q0, 0.0)
            # print('interstorm q:%f, q2:%f'%(q[4], q2[4]))
            self.max_substeps_interstorm = max(
                self.max_substeps_interstorm, self.gdp.number_of_substeps
            )

            # record interevent
            self.time[i * 2 + 2] = self.time[i * 2 + 1] + self.interstorm_dts[i]
            self.Q_all[i * 2 + 2, :] = self._grid.at_node["surface_water__discharge"]
            self.wt_all[i * 2 + 2, :] = self._grid.at_node["water_table__elevation"]
            self.qs_all[i * 2 + 2, :] = self._grid.at_node[
                "average_surface_water__specific_discharge"
            ]

            # volume of runoff contributed during timestep
            q_total_vol += q1 * self.storm_dts[i] + q2 * self.interstorm_dts[i]

        self.q_eff[:] = q_total_vol / self.T_h
        self.q_an[:] = np.divide(
            self.q_eff,
            np.sqrt(self.area),
            where=self.area > 0,
            out=np.zeros_like(self.q_eff),
        )


class HydrologyEventVadoseStreamPower(HydrologyEventStreamPower):
    """"
    This model expands HydrologyEventStreamPower for the case where
    there is vadose zone storage and evapotranspiration. The SchenkVadoseModel
    is used to determine recharge and extraction of water to/from the water
    table in storm events and interevents respectively. One vadose profile is
    tracked and this is used to map recharge and extration rates based on
    depth to water table across grid. Two new grid fields, "recharge_rate" and
    "extraction_rate" are added as recharge and extraction can vary spatially.
    While they are both used to set the GroundwaterDupuitPercolator recharge field
    ultimately, it is helpful to have separate grid fields because one timestep
    incorporates recharge and extraction periods.

    Parameters
    -----
    grid: landlab grid
    routing_method: string, either "D8" or "Steepest"
    precip_generator: instantiated PrecipitationDistribution
    groundwater_model: instantiated GroundwaterDupuitPercolator
    vadose_model: instantiated SchenkVadoseModel

    """

    def __init__(
        self,
        grid,
        routing_method="D8",
        precip_generator=None,
        groundwater_model=None,
        vadose_model=None,
    ):
        super().__init__(grid, routing_method, precip_generator, groundwater_model)

        self.svm = vadose_model
        self.r = self._grid.add_zeros("node", "recharge_rate")
        self.e = self._grid.add_zeros("node", "extraction_rate")
        self._elev = self._grid.at_node["topographic__elevation"]
        self._wt = self._grid.at_node["water_table__elevation"]

    def run_step(self):
        """"
        Run hydrological model for series of event-interevent pairs, calculate
        flow rates at end of events and interevents over total_hydrological_time.
        Initially generate exponential precip, fill pits, find flow directions,
        calculate critical erosion rate. Through storm-interstorm pairs,
        update vadose model state, calculate recharge, update groundwater state,
        route flow, calculate additional erosion-generating flow. After, calculate
        surface_water_effective__discharge and surface_water_area_norm__discharge.
        """
        cores = self._grid.core_nodes

        # find and route flow if there are pits
        self.dfr._find_pits()
        if self.dfr._number_of_pits > 0:
            self.lmb.run_one_step()

        # update flow directions
        self.fd.run_one_step()

        self.max_substeps_storm = 0
        self.max_substeps_interstorm = 0
        q_total_vol = np.zeros_like(self.q_eff)
        for (storm_dt, interstorm_dt) in self.pd.yield_storms():

            intensity = float(self._grid.at_grid["rainfall__flux"])

            # run event:
            ## run vadose model, calculate recharge based on depth to wt
            self.svm.run_event(intensity * storm_dt)
            wt_from_surface = self._elev[cores] - self._wt[cores]
            self.r[cores] = self.svm.calc_recharge_rate(wt_from_surface, storm_dt)
            ## set recharge, run groundwater model, accumulate flow
            self.gdp.recharge = self.r
            self.gdp.run_with_adaptive_time_step_solver(storm_dt)
            _, q = self.fa.accumulate_flow(update_flow_director=False)
            q1 = q.copy()
            self.max_substeps_storm = max(
                self.max_substeps_storm, self.gdp.number_of_substeps
            )

            # run interevent:
            ## run vadose model, calculate the extraction below the water table
            ## due to ET.
            self.svm.run_interevent(interstorm_dt)
            wt_from_surface = self._elev[cores] - self._wt[cores]
            self.e[cores] = self.svm.calc_extraction_rate(
                wt_from_surface, interstorm_dt
            )
            # set extraction, run groundwater model, accumulate flow
            self.gdp.recharge = self.e
            self.gdp.run_with_adaptive_time_step_solver(max(interstorm_dt, 1e-15))
            _, q = self.fa.accumulate_flow(update_flow_director=False)
            q2 = q.copy()
            self.max_substeps_interstorm = max(
                self.max_substeps_interstorm, self.gdp.number_of_substeps
            )

            # volume of runoff contributed during timestep
            q_total_vol += q1 * storm_dt + q2 * interstorm_dt

        # set effective runoff rates
        self.q_eff[:] = q_total_vol / self.T_h
        self.q_an[:] = np.divide(
            self.q_eff,
            np.sqrt(self.area),
            where=self.area > 0,
            out=np.zeros_like(self.q_eff),
        )

    def run_step_record_state(self):
        """"
        Run hydrological model for series of event-interevent pairs, calculate
        flow rates at end of events and interevents over total_hydrological_time.
        Initially generate exponential precip, fill pits, find flow directions,
        calculate critical erosion rate. Through storm-interstorm pairs,
        update vadose model state, calculate recharge, update groundwater state,
        route flow, calculate additional erosion-generating flow. After, calculate
        surface_water_effective__discharge and surface_water_area_norm__discharge.

        track the state of the model:
            time: (s)
            intensity: rainfall intensity (m/s)
            wtrel_all: relative water table position (-)
            qs_all: surface water specific discharge (m/s)
            Q_all: discharge (m3/s)

        """
        cores = self._grid.core_nodes

        # generate new precip time series
        self.generate_exp_precip()

        # find and route flow if there are pits
        self.dfr._find_pits()
        if self.dfr._number_of_pits > 0:
            self.lmb.run_one_step()

        # update flow directions
        self.fd.run_one_step()

        # fields to record:
        Ns = 2 * len(self.storm_dts) + 1
        N = len(self.q_eff)
        self.time = np.zeros(Ns)
        self.intensity = np.zeros(Ns)
        # all discharge
        self.Q_all = np.zeros((Ns, N))
        # water table elevation
        self.wt_all = np.zeros((Ns, N))
        self.wt_all[0, :] = self._grid.at_node["water_table__elevation"].copy()
        # all surface water specific discharge
        self.qs_all = np.zeros((Ns, N))
        # all recharge
        self.r_all = np.zeros((Ns, N))

        # vadose profile properties
        self.cum_recharge_profile = np.zeros_like(self.svm.depths)
        self.bool_recharge_profile = np.zeros_like(self.svm.depths)

        # precip/recharge spatially-averaged properties
        areas = self._grid.cell_area_at_node[cores]
        obn = self._grid.open_boundary_nodes
        self.cum_precip = 0.0
        self.cum_recharge = 0.0
        self.cum_runoff = 0.0

        self.max_substeps_storm = 0
        self.max_substeps_interstorm = 0

        q_total_vol = np.zeros_like(self.q_eff)
        # q2 = np.zeros_like(self.q_eff)
        for i in range(len(self.storm_dts)):
            # q0 = q2.copy()  # save prev end of interstorm flow rate

            # run event:
            ## run vadose model, calculate recharge based on depth to wt
            self.svm.run_event(self.intensities[i] * self.storm_dts[i])
            wt_from_surface = self._elev[cores] - self._wt[cores]
            self.r[cores] = self.svm.calc_recharge_rate(
                wt_from_surface, self.storm_dts[i]
            )
            ## set recharge, run groundwater model, accumulate flow
            self.gdp.recharge = self.r
            self.gdp.run_with_adaptive_time_step_solver(self.storm_dts[i])
            _, q = self.fa.accumulate_flow(update_flow_director=False)
            q1 = q.copy()
            self.max_substeps_storm = max(
                self.max_substeps_storm, self.gdp.number_of_substeps
            )

            # record event
            self.time[i * 2 + 1] = self.time[i * 2] + self.storm_dts[i]
            self.intensity[i * 2] = self.intensities[i]
            self.r_all[i * 2, :] = self._grid.at_node["recharge_rate"]
            self.Q_all[i * 2 + 1, :] = self._grid.at_node["surface_water__discharge"]
            self.wt_all[i * 2 + 1, :] = self._grid.at_node["water_table__elevation"]
            self.qs_all[i * 2 + 1, :] = self._grid.at_node[
                "average_surface_water__specific_discharge"
            ]

            # run interevent:
            ## run vadose model, calculate the extraction below the water table
            ## due to ET.
            self.svm.run_interevent(self.interstorm_dts[i])
            wt_from_surface = self._elev[cores] - self._wt[cores]
            self.e[cores] = self.svm.calc_extraction_rate(
                wt_from_surface, self.interstorm_dts[i]
            )

            # set extraction, run groundwater model, accumulate flow
            self.gdp.recharge = self.e
            self.gdp.run_with_adaptive_time_step_solver(
                max(self.interstorm_dts[i], 1e-15)
            )
            _, q = self.fa.accumulate_flow(update_flow_director=False)
            q2 = q.copy()
            self.max_substeps_interstorm = max(
                self.max_substeps_interstorm, self.gdp.number_of_substeps
            )

            # record interevent
            self.time[i * 2 + 2] = self.time[i * 2 + 1] + self.interstorm_dts[i]
            self.Q_all[i * 2 + 2, :] = self._grid.at_node["surface_water__discharge"]
            self.wt_all[i * 2 + 2, :] = self._grid.at_node["water_table__elevation"]
            self.qs_all[i * 2 + 2, :] = self._grid.at_node[
                "average_surface_water__specific_discharge"
            ]

            # record vadose characteristics
            self.cum_recharge_profile += self.svm.recharge_at_depth
            self.bool_recharge_profile += self.svm.recharge_at_depth > 0.0

            # record precip/recharge spatially-averaged characteristics
            self.cum_precip += np.sum(self.intensities[i] * areas) * self.storm_dts[i]
            self.cum_recharge += np.sum(self.r[cores] * areas) * self.storm_dts[i]
            self.cum_runoff += np.sum(
                q1[obn] * self.storm_dts[i] + q2[obn] * self.interstorm_dts[i]
            )

            # volume of runoff contributed during timestep
            q_total_vol += q1 * self.storm_dts[i] + q2 * self.interstorm_dts[i]

        self.q_eff[:] = q_total_vol / self.T_h
        self.q_an[:] = np.divide(
            self.q_eff,
            np.sqrt(self.area),
            where=self.area > 0,
            out=np.zeros_like(self.q_eff),
        )

        # derived properties
        # mean recharge at each vadose profile
        self.mean_recharge_depth = (
            self.cum_recharge_profile / self.bool_recharge_profile
        )
        # frequency of recharge in vadose profile
        self.recharge_frequency = self.bool_recharge_profile / self.T_h


class HydrologyEventVadoseThresholdStreamPower(HydrologyEventStreamPower):
    """
    This model combines additions to the HydrologyEventStreamPower model for
    cases where there is a streampower incision threshold and vadose
    storate/evapotranspiration. As with HydrologyEventThresholdStreamPower,
    rather than tracking discharge at storms and interstorms, erosion-producing
    discharge Q-Q0 is tracked, and returned in a fashion that is correctly
    averaged with threshold accounted for in the field "surface_water_effective__discharge".
    CONSEQUENTLY ONE SHOULD LEAVE THE INCISION THRESHOLD FIELD OF
    FastscapeEroder SET TO ZERO! For the same reason, this field has a different
    meaning when using the threshold model: it is not an actual discharge,
    but an effective value that also accounts for geomorphic properties related
    to the threshold streampower.

    Parameters
    -----
    grid: landlab grid
    routing_method: either "D8" or "Steepest"
    precip_generator: instantiated PrecipitationDistribution
    groundwater_model: instantiated GroundwaterDupuitPercolator
    vadose_model: instantiated SchenkVadoseModel
    E0: the streampower incision threshold in the equation
        E = K v0 Q* sqrt(a) S - E0, where Q*=Q/(pA). Units: L/T
        Default value: 0.0
    sp_coefficient: streampower coefficient used in the FastscapeEroder
        component. Note that in DupuitLEM, the expected value has units 1/L,
        because it takes a coefficient K/p, where K is the usual streampower
        coefficient, with units 1/T, and p is the mean precipitation rate with
        units L/T.
        Default value: 1e-12
    """

    def __init__(
        self,
        grid,
        routing_method="D8",
        precip_generator=None,
        groundwater_model=None,
        vadose_model=None,
        sp_threshold=0.0,
        sp_coefficient=1e-5,
    ):
        super().__init__(grid, routing_method, precip_generator, groundwater_model)
        self.svm = vadose_model
        self.r = self._grid.add_zeros("node", "recharge_rate")
        self._elev = self._grid.at_node["topographic__elevation"]
        self._wt = self._grid.at_node["water_table__elevation"]

        self.E0 = sp_threshold
        self.Ksp = sp_coefficient
        self.Q0 = self._grid.add_zeros("node", "critical_erosion__discharge")
        self._recievers = self._grid.at_node["flow__link_to_receiver_node"]

        if routing_method == "D8":
            self._calc_grad = self._grid.calc_grad_at_d8
        else:
            self._calc_grad = self._grid.calc_grad_at_link

    def run_step(self):
        """"
        Run hydrological model for series of event-interevent pairs, calculate
        flow rates at end of events and interevents over total_hydrological_time.
        Initially generate exponential precip, fill pits, find flow directions,
        calculate critical erosion rate. Through storm-interstorm pairs,
        update vadose model state, calculate recharge, update groundwater state,
        route flow, calculate additional erosion-generating flow. After, calculate
        surface_water_effective__discharge and surface_water_area_norm__discharge.
        """
        cores = self._grid.core_nodes

        # find and route flow if there are pits
        self.dfr._find_pits()
        if self.dfr._number_of_pits > 0:
            self.lmb.run_one_step()

        # update flow directions
        self.fd.run_one_step()

        # calculate critical_erosion__discharge
        dzdx = self._calc_grad(self._elev)
        S = abs(dzdx[self._recievers])  # slope is in direction of flow
        _, _ = self.fa.accumulate_flow(update_flow_director=False)  # to update area
        self.Q0[:] = np.divide(
            self.E0 * np.sqrt(self.area),
            self.Ksp * S,
            where=S > 0.0,
            out=np.zeros_like(S),
        )

        self.max_substeps_storm = 0
        self.max_substeps_interstorm = 0
        q_total_vol = np.zeros_like(self.q_eff)
        for (storm_dt, interstorm_dt) in self.pd.yield_storms():

            intensity = float(self._grid.at_grid["rainfall__flux"])
            # run event:
            ## run vadose model, calculate recharge based on depth to wt
            self.svm.run_event(intensity * storm_dt)
            wt_from_surface = self._elev[cores] - self._wt[cores]
            self.r[cores] = self.svm.calc_recharge_rate(wt_from_surface, storm_dt)

            ## set recharge, run groundwater model, accumulate flow
            self.gdp.recharge = self.r
            self.gdp.run_with_adaptive_time_step_solver(storm_dt)
            _, q = self.fa.accumulate_flow(update_flow_director=False)
            q1 = np.maximum(q - self.Q0, 0.0)
            # print('storm q:%f, q1:%f'%(q[4], q1[4]))
            self.max_substeps_storm = max(
                self.max_substeps_storm, self.gdp.number_of_substeps
            )

            # run interevent:
            ## run vadose model, calculate the extraction below the water table
            ## due to ET.
            self.svm.run_interevent(interstorm_dt)
            wt_from_surface = self._elev[cores] - self._wt[cores]
            self.r[cores] = self.svm.calc_extraction_rate(
                wt_from_surface, interstorm_dt
            )

            # set extraction, run groundwater model, accumulate flow
            self.gdp.recharge = self.r
            self.gdp.run_with_adaptive_time_step_solver(max(interstorm_dt, 1e-15))
            _, q = self.fa.accumulate_flow(update_flow_director=False)
            q2 = np.maximum(q - self.Q0, 0.0)
            # print('interstorm q:%f, q2:%f'%(q[4], q2[4]))
            self.max_substeps_interstorm = max(
                self.max_substeps_interstorm, self.gdp.number_of_substeps
            )

            # volume of runoff contributed during timestep
            q_total_vol += q1 * storm_dt + q2 * interstorm_dt
            # print('storm dt:%f'%storm_dt)

        self.q_eff[:] = q_total_vol / self.T_h
        self.q_an[:] = np.divide(
            self.q_eff,
            np.sqrt(self.area),
            where=self.area > 0,
            out=np.zeros_like(self.q_eff),
        )

    def run_step_record_state(self):
        """"
        Run hydrological model for series of event-interevent pairs, calculate
        flow rates at end of events and interevents over total_hydrological_time.
        Initially generate exponential precip, fill pits, find flow directions,
        calculate critical erosion rate. Through storm-interstorm pairs,
        update vadose model state, calculate recharge, update groundwater state,
        route flow, calculate additional erosion-generating flow. After, calculate
        surface_water_effective__discharge and surface_water_area_norm__discharge.

        track the state of the model:
            time: (s)
            intensity: rainfall intensity (m/s)
            wtrel_all: relative water table position (-)
            qs_all: surface water specific discharge (m/s)
            Q_all: discharge (m3/s)
            r_all: spatially-distributed recharge rate (m/s)
            cum_recharge_profile: cumulative recharge given wt depth
            bool_recharge_profile: boolean of whether recharge has occurred at
                wt depth
            mean_recharge_depth: Mean depth of recharge at wt depth given recharge
                occurred. cum_recharge_profile/bool_recharge_profile
            recharge_frequency: frequency of recharge events at wt depth.
                bool_recharge_profile/T_h
            cum_precip: cumulative precip over simulation (m3)
            cum_recharge: cumulative recharge over simulation (m3)
            cum_runoff: cumulative runoff (surface flow leaving open boundary nodes)
                over simulation (m3)

        """
        cores = self._grid.core_nodes

        # generate new precip time series
        self.generate_exp_precip()

        # find and route flow if there are pits
        self.dfr._find_pits()
        if self.dfr._number_of_pits > 0:
            self.lmb.run_one_step()

        # update flow directions
        self.fd.run_one_step()

        # calculate critical_erosion__discharge
        dzdx = self._calc_grad(self._elev)
        S = abs(dzdx[self._recievers])  # slope is in direction of flow
        _, _ = self.fa.accumulate_flow(update_flow_director=False)  # to update area
        self.Q0[:] = np.divide(
            self.E0 * np.sqrt(self.area),
            self.Ksp * S,
            where=S > 0.0,
            out=np.zeros_like(S),
        )

        # fields to record:
        Ns = 2 * len(self.storm_dts) + 1
        N = len(self.q_eff)
        self.time = np.zeros(Ns)
        self.intensity = np.zeros(Ns)
        # all discharge
        self.Q_all = np.zeros((Ns, N))
        # water table elevation
        self.wt_all = np.zeros((Ns, N))
        self.wt_all[0, :] = self._grid.at_node["water_table__elevation"].copy()
        # all surface water specific discharge
        self.qs_all = np.zeros((Ns, N))
        self.r_all = np.zeros((Ns, N))

        # vadose profile properties
        self.cum_recharge_profile = np.zeros_like(self.svm.depths)
        self.bool_recharge_profile = np.zeros_like(self.svm.depths)

        # precip/recharge spatially-averaged properties
        areas = self._grid.cell_area_at_node[cores]
        obn = self._grid.open_boundary_nodes
        self.cum_precip = 0.0
        self.cum_recharge = 0.0
        self.cum_runoff = 0.0

        self.max_substeps_storm = 0
        self.max_substeps_interstorm = 0

        q_total_vol = np.zeros_like(self.q_eff)
        # q2 = np.zeros_like(self.q_eff)
        for i in range(len(self.storm_dts)):
            # q0 = q2.copy()  # save prev end of interstorm flow rate

            # run event:
            ## run vadose model, calculate recharge based on depth to wt
            self.svm.run_event(self.intensities[i] * self.storm_dts[i])
            wt_from_surface = self._elev[cores] - self._wt[cores]
            self.r[cores] = self.svm.calc_recharge_rate(
                wt_from_surface, self.storm_dts[i]
            )

            ## set recharge, run groundwater model, accumulate flow
            self.gdp.recharge = self.r
            self.gdp.run_with_adaptive_time_step_solver(self.storm_dts[i])
            _, q = self.fa.accumulate_flow(update_flow_director=False)
            q1 = np.maximum(q - self.Q0, 0.0)
            # print('storm q:%f, q1:%f'%(q[4], q1[4]))
            self.max_substeps_storm = max(
                self.max_substeps_storm, self.gdp.number_of_substeps
            )

            # record event
            self.time[i * 2 + 1] = self.time[i * 2] + self.storm_dts[i]
            self.intensity[i * 2] = self.intensities[i]
            self.r_all[i * 2, :] = self._grid.at_node["recharge_rate"]
            self.Q_all[i * 2 + 1, :] = self._grid.at_node["surface_water__discharge"]
            self.wt_all[i * 2 + 1, :] = self._grid.at_node["water_table__elevation"]
            self.qs_all[i * 2 + 1, :] = self._grid.at_node[
                "average_surface_water__specific_discharge"
            ]

            # run interevent:
            ## run vadose model, calculate the extraction below the water table
            ## due to ET.
            self.svm.run_interevent(self.interstorm_dts[i])
            wt_from_surface = self._elev[cores] - self._wt[cores]
            self.r[cores] = self.svm.calc_extraction_rate(
                wt_from_surface, self.interstorm_dts[i]
            )

            # set extraction, run groundwater model, accumulate flow
            self.gdp.recharge = self.r
            self.gdp.run_with_adaptive_time_step_solver(
                max(self.interstorm_dts[i], 1e-15)
            )
            _, q = self.fa.accumulate_flow(update_flow_director=False)
            q2 = np.maximum(q - self.Q0, 0.0)
            # print('interstorm q:%f, q2:%f'%(q[4], q2[4]))
            self.max_substeps_interstorm = max(
                self.max_substeps_interstorm, self.gdp.number_of_substeps
            )

            # record interevent
            self.time[i * 2 + 2] = self.time[i * 2 + 1] + self.interstorm_dts[i]
            self.Q_all[i * 2 + 2, :] = self._grid.at_node["surface_water__discharge"]
            self.wt_all[i * 2 + 2, :] = self._grid.at_node["water_table__elevation"]
            self.qs_all[i * 2 + 2, :] = self._grid.at_node[
                "average_surface_water__specific_discharge"
            ]

            # record vadose characteristics
            self.cum_recharge_profile += self.svm.recharge_at_depth
            self.bool_recharge_profile += self.svm.recharge_at_depth > 0.0

            # record precip/recharge spatially-averaged characteristics
            self.cum_precip += np.sum(self.intensities[i] * areas) * self.storm_dts[i]
            self.cum_recharge += np.sum(self.r[cores] * areas) * self.storm_dts[i]
            self.cum_runoff += np.sum(
                q1[obn] * self.storm_dts[i] + q2[obn] * self.interstorm_dts[i]
            )

            # volume of runoff contributed during timestep
            q_total_vol += q1 * self.storm_dts[i] + q2 * self.interstorm_dts[i]

        self.q_eff[:] = q_total_vol / self.T_h
        self.q_an[:] = np.divide(
            self.q_eff,
            np.sqrt(self.area),
            where=self.area > 0,
            out=np.zeros_like(self.q_eff),
        )

        # derived properties
        # mean recharge at each vadose profile
        self.mean_recharge_depth = (
            self.cum_recharge_profile / self.bool_recharge_profile
        )
        # frequency of recharge in vadose profile
        self.recharge_frequency = self.bool_recharge_profile / self.T_h
